# Elasticsearch
- 검색이랑 데이터분석에 최적화된 데이터베이스

<br>

## ✅ 주요 활용 사례
1. 검색 최적화
    - 데이터가 많더라도 뛰어난 검색 속도를 가지고 있고, 오타나 동의어를 고려해서 유연하게 검색할 수 있는 기능을 가지고 있다
    - 쿠팡이나 배달의 민족의 검색 기능도 Elasticsearch 활용
2. 데이터 수집 및 분석
    - 대규모 데이터를 수집 및 분석하는데 최적화되어 있다


<br><br>

## 📝 간단 용어 대응표: RDB vs Elasticsearch

| RDB (관계형 DB)               | Elasticsearch                   |
| ----------------------------- | ------------------------------- |
| **Database**                  | **Index**                       |
| **Table**                     | **Type** (← 현재는 거의 폐지됨) |
| **Row**                       | **Document**                    |
| **Column**                    | **Field**                       |
| **Schema**                    | **Mapping**                   |
| **DBMS 서버 전체**            | **Cluster**                     |
| **DB 서버의 물리적 인스턴스** | **Node**                        |

<br>

### Elasticsearch 용어
- **인덱스** : 관련 문서를 저장하고 구조화하는 장소
    - **샤드** : 색인 및 검색 요청을 처리할 수 있는 루씬 인덱스의 인스턴스다
    - 인덱스는 프라이머리 샤드, 레플리카 샤드로 구성된다
    - **프라이머리 샤드**
        - 읽기 및 쓰기 요청을 모두 처리
    - **레플리카 샤드**
        - 읽기 전용
    - 프라이머리 및 레플리카 샤드는 항상 서로 다른 노드에 할당되어 다중성과 확장성을 제공
    - | 손실 상황                               | 시스템 동작                                                  | 영향                                | 자동 복구 여부 |
        | --------------------------------------- | ------------------------------------------------------------ | ----------------------------------- | -------------- |
        | **Primary Shard 손실 (Replica 존재)** | 클러스터가 **Replica를 새로운 Primary로 승격**               | ✅ 서비스 유지 가능 (읽기/쓰기 가능) | ✅ 자동 복구    |
        | **Replica Shard 손실 (Primary 존재)** | Primary는 정상이므로 영향 없음 Replica를 다시 다른 노드에 **자동 생성** | ✅ 서비스 지속 가능 (읽기/쓰기 가능) | ✅ 자동 복구    |
        | **Primary + Replica 모두 손실**       | 해당 샤드의 데이터 완전 소실 검색/색인 불가                  | ❌ 데이터 손실 서비스 장애 발생      | ❌ 불가능       |
- **색인(Indexing)** : 문서를 엘라스틱서치 인덱스에 기록하는 작업
- **document(문서)** : 인덱스에 저장된 JSON 객체
- **매핑** : 인덱스 내 필드들의 구조/데이터형을 정의, 각 필드의 데이터 유형을 지정하고 검색을 위해 필드를 색인하고 분석하는 방법을 결정
- **노드** : 엘라스틱서치의 단일 실행 인스턴스(하나의 실행 단위)

<br><br>

## 🔧 내부 구조
```scss
클러스터
 ├─ 노드 A
 │   ├─ 샤드: products 인덱스의 Primary-0
 │   └─ 샤드: logs 인덱스의 Replica-2
 ├─ 노드 B
 │   └─ 샤드: products 인덱스의 Replica-0
 │
└─ 인덱스
    ├─ products (2 primary shards, 1 replica each)
    │    ├─ Primary-0 → Node A
    │    ├─ Primary-1 → Node B
    │    ├─ Replica-0 → Node B
    │    └─ Replica-1 → Node A
    └─ logs ...
```
- 인덱스는 여러 개의 샤드로 나뉘고,
- 이 샤드들이 클러스터 내 여러 노드에 분산 저장된다

<br><br>

## ✔️ 핵심 API
| API 경로            | 의미 / 설명                                                  |
| ------------------- | ------------------------------------------------------------ |
| `/_doc`             | **단일 문서(document)**를 생성하거나 조회, 삭제, 수정할 때 사용 → 문서를 직접 다룰 때 |
| `/_search`          | **문서 검색**을 수행할 때 사용 → 조건에 맞는 문서 리스트를 검색 |
| `/_bulk`            | **여러 개의 문서를 한 번에 처리**할 때 사용 → index, update, delete 다 가능 |
| `/_mapping`         | 인덱스의 **필드 구조(스키마)**를 설정하거나 조회할 때        |
| `/_settings`        | 인덱스의 **설정값(샤드 수, 복제 수, 파이프라인 등)**을 설정하거나 조회 |
| `/_alias`           | 인덱스에 붙이는 **별칭(alias)** 을 추가/조회/삭제            |
| `/_delete_by_query` | 조건에 맞는 문서를 **일괄 삭제**할 때                        |
| `/_update_by_query` | 조건에 맞는 문서를 **일괄 수정**할 때                        |
| `/_analyze`         | 텍스트를 토큰화해서 **분석(analyze)** 결과를 확인할 때       |
| `/_cat`             | Elasticsearch의 **상태나 메타 정보**를 사람이 보기 좋게 출력 (예: `_cat/indices`) |
| `/_ingest/pipeline` | 인제스트 파이프라인을 만들거나 조회, 수정할 때               |

<br><br>

## 🔍 데이터 색인과 검색

<br>

### 인덱싱과 검색 성능 최적화
- 기본적으로 하나의 인덱스를 생성할 때
    - Primary Shard (기본 샤드): 1개
    - Replica Shard (복제 샤드): 1개 (Primary Shard의 복제본)
- 인덱스는 여러 개의 샤드로 구성될 수 있다
- 샤드 개수가 늘어날수록 데이터의 **확장성, 성능, 안정성**에 직결된다
- 너무 작은 데이터에 샤드를 많이 만들면 오히려 느려지고 비효율적이다

<br>

참고
> 레플리카 카드는 각 프라이머리 샤드마다 할당된다.   
> 예로는 2개의 프라이머리 샤드, 1개의 레플리카 샤드면 총 4개의 샤드 할당된다(각 프라이머리 샤드마다 1개의 레플리카 샤드)   
> 2개 프라이머리, 2개의 레플리카 인덱스는 총 6개 샤드로 구성

<br>

따라서
- 검색 성능 최적화 하려면 샤드를 전체 노드에 균등하게 분산해야 한다
- 30GB ~ 50GB 사이의 데이터를 저장하는 것을 권장
    - 예로는
    - 고성능 검색 -> 작은 샤드가 빠른 검색과 집계에 이점
    - 로깅 작업 -> 클러스터에 많은 데이터를 저장할 수 있게 큰 샤드가 적합

<br>

### 매핑
- 엘라스틱서치는 자동으로 동적 인덱스 매핑을 생성할 수 있다
- 인덱스 매핑은 제거하거나 변경할 수 없다
- 따라서 인덱스 스키마를 알고 있다면 인덱스 매핑을 정의하는게 좋다

<br>

### 주요 데이터 타입들 
- 매핑할때 정의하는 데이터 타입들이다

| 타입                       | 설명                                     |
| -------------------------- | ---------------------------------------- |
| `text`                     | 전체 텍스트 검색용 (ex. 제품명, 설명 등) |
| `keyword`                  | 정렬/집계용 문자열 (ex. 카테고리, ID 등) |
| `integer`, `float`, `long` | 숫자형 데이터                            |
| `boolean`                  | true / false                             |
| `date`                     | IPv4, IPv6                              |
| `geo_point`                | 위도/경도 좌표                           |
| `object`                   | JSON 문서에 내부 객체                    |
| `array`                    | 배열, 하나의 배열은 단일 데이터만 보유     |
| `nested`                   | 중첩 타입, 객체 내부의 연관성 정보 유지    |
| `join`                     | 문서 간에 부모/자식 관계를 만듬           |

<br>

### 문서 ID 생성
- 자동으로 문서 ID 생성하는 것이 더 효율적이며 색인 성능도 향상된다
    - 범용 고유 식별자(UUID)를 사용하므로
- 반면, ID를 직접 설정하면 색인 작업을 하기 전에 동일한 _id 프라이머리 샤드에 이미 존재하는지 확인하는 작업을 진행

<br>


### 엘라스틱서치 노드
| 노드 종류                                 | 역할                                                         | 설정 키                              |
| ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------ |
| 🌐 **마스터 노드 (Master Node)**           | 클러스터 상태 관리, 노드 추가/제거, 인덱스 생성 등 **전체 제어 역할** | `node.roles: [ master ]`             |
| 📦 **데이터 노드 (Data Node)**             | 실제 데이터를 저장하고, 색인(indexing), 검색(query) 처리 담당 | `node.roles: [ data ]`               |
| 🛠 **인제스트 노드 (Ingest Node)**         | 색인 전에 데이터를 전처리(파이프라인 실행 등)                | `node.roles: [ ingest ]`             |
| 💬 **코디네이팅 노드 (Coordinating Node)** | 사용자가 보낸 요청을 다른 노드에 전달하고 결과를 종합 → **프록시 역할** | 역할 없음 (`node.roles` 비워두면 됨) |
| 📁 **머신러닝 노드 (ML Node)**             | 머신러닝 분석 (anomaly detection 등) 담당                    | `node.roles: [ ml ]`                 |


<br><br>

## 📈 데이터 분석과 관리

### 집계
> 집계는 대용량의 데이터를 사용하기 쉬운 데이터로 요약
- **매트릭 집계** : 숫자 데이터에 대한 개수, 합계, 최솟값, 최댓값, 평균 같은 매트릭을 계산
- **버킷 집계** : 대규모 데이터 세트를 필드의 값에 따라 그룹화한다

<br>

집계 사용 예
- 데이터를 시각화하는 키바나의 시각화, 대시보드, 솔루션별 애플리케이션
- 지도 및 비지도 머신러닝 작업
- 엔티티 중심 인덱스의 변환 작업

<br><br>

### 시계열 데이터의 수명주기 관리

<br>

- 데이터는 시간이 지날수록 유용성이 달라진다
  - 초기에는 실시간 분석이나 즉각 대응이 목적
  - 시간이 지나면 통계/분석/보고용으로 바뀜
  - 더 오래 지나면 참고 기록, 보존, 감사의 목적만 남음

<br>

Elasticsearch에서는
- 이 흐름을 반영해 Hot → Warm → Cold → Frozen 계층을 사용
- ILM 정책으로 시간 경과에 따라 자동 이동시켜 성능과 비용을 동시에 관리

<br>

데이터 계층 구조
| 계층         | 설명                                          | 주요 용도                  |  조회 속도                | 
| ------------ | --------------------------------------------- | --------------------------  | ------------------------ | 
| 🔥 **Hot**    | 최신 데이터, 가장 자주 쓰이고 검색됨          | 실시간 로그 분석, 대시보드 | 매우 빠름                | 
| 🌤 **Warm**   | 약간 지난 데이터, 자주 검색되진 않지만 필요함 | 준실시간 검색, 저장         | 빠름                     | 
| ❄️ **Cold**   | 거의 사용되지 않지만 삭제하긴 아까움          | 감사 로그, 보관용 데이터   | 느림                     | 
| 🧊 **Frozen** | 거의 조회되지 않음, 저장만 함                 | 장기 보관, 규제 준수       | 매우 느림 (캐싱 후 검색) | 

<br>

### 인덱스 생명주기 관리
> ILM(인덱스 생명주기 관리) 정책은 인덱스 수명주기 내의 다양한 단계와 각 단계마다 데이터 전환으로 수행할 작업을 정의하기 위해 설정한다

<br>

ILM 개념
- **쓰기 별칭**: 사용자는 현재 활성화된 쓰기 인덱스를 알 필요 없이 별칭으로 접근해서 인덱스에 문서를 작성
- **부트스트랩 인덱스**: 연속적인 데이터스트림을 색인하고 괸리하기 위해 수동으로 생성해야 하는 초기 인덱스
- **인덱스 롤오버**: 새 인덱스가 생성되고 쓰기 별칭이 새 인덱스를 가리키도록 변경되는것
  -** 이전 인덱스는 읽기 전용 상태로 간주
- **데이터 스트림**: IML울 사용해 추가 전용 시계열 데이터 세트를 좀 더 쉽게 설정하고 관리

<br>

요즘 IML
- 요즘에는 데이터 스트림 + ILM 조합이
  - ✔️ 설정도 간단하고
  - ✔️ Kibana UI와도 자연스럽게 연결되고
  - ✔️ 유지보수도 편해서
- 로그 수집이나 시계열 데이터 관리에 사실상 표준처럼 사용된다

<br><br>

### 인제스트 파이프라인
> 로그스태시 같은 ETL 도구의 사용 없이 가볍고 편리하게 데이터를 변환하고 가공한다  
> 인제스트 파이프라인은 엘라스틱서치 노드에서 실행되므로 추가적인 관리 오버헤드 없이 클러스터의 일부로 쉽게 확장할 수 있다

<br>

주요 역할
- 원시(raw) 데이터를 분석 가능한 구조로 변환
- 필드 추가/변경/삭제
- IP → 지리 정보(GeoIP), 문자열 파싱, 정규식 처리 등



<br><br>

### 워처